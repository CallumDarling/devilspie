%h{
#define WNCK_I_KNOW_THIS_IS_UNSTABLE
#include "libwnck/window.h"
#include "tristate-dummy.h"
#include "devilspie-action.h"
#include "devilspie.h"

#define WINDOW_TITLE_TOK "$TITLE"
#define WINDOW_ID_TOK   "$ID"
#define MAX_COMMAND_LEN  255
%}

/*
 * This class will execute arbitrary commands when a devilspie action is called.
 * The command run is defined by the command property which can be written just
 * as it would an a command line.  The reserved words $TITLE and $ID are
 * replaced with the window's title or xid.  This is for use with such programs
 * as wmctrl which can perform many actions on windows.  Devilspie provides the
 * ability to recognize them, and wmctrl can act on the windows.  Of course,
 * shell scripts can also be called from here and be passed the title or id for
 * whatever the user wishes.
 *
 * Note of caution.  Don't go trying to call xterm when you see an xterm window,
 * this will cause an infinite loop.  Don't cross the streams.
 */
class DevilsPie:Action:Exec from DevilsPie:Action {
  
  public gchar * command;
  
  property STRING command
    (nick = _("Command to execute"),
     blurb = _("This command and any arguments will be run.  The title of the window and the window ID will be passed to the command as the first and second arguments"),
     default_value = NULL,
     flags = CONSTRUCT,
     link);
  
  override (DevilsPie:Action) gboolean run(DevilsPie:Action *self (check null type), Wnck:Window *window (check null type)) {
    GError *err = NULL;
    gchar **command_argv;
    gint command_argc, i;
    gchar *command = DEVILSPIE_ACTION_EXEC(self)->command;
    
    /* Replace window title and ID tokens with the actual title and ID */
    if (g_shell_parse_argv(command, &command_argc, &command_argv, &err)) {
      for (i = 0; i < command_argc; ++i) {
        if (strcmp(command_argv[i], WINDOW_TITLE_TOK) == 0) {
          g_free (command_argv[i]);
          command_argv[i] = g_strdup(wnck_window_get_name(window));
        } else if (strcmp(command_argv[i], WINDOW_ID_TOK) == 0) {
          g_free (command_argv[i]);
          command_argv[i] = g_strdup_printf("%ld", wnck_window_get_xid(window));
        }
      }
      /* Run the command asynchronously  */
      g_spawn_async(NULL, command_argv, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, NULL, &err);
      g_strfreev(command_argv);
    }
    if (err) {
      /* Report error to user, and free error */
      g_warning("Cannot spawn: %s", err->message);
      g_error_free(err);
      return FALSE;
    }
    return TRUE;
  }
  
  public GObject *new(void) {
    return (GObject*)GET_NEW;
  }
}
